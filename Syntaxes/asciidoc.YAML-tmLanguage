# [PackageDev] target_format: plist, ext: tmLanguage
name: AsciiDoc (new)
scopeName: text.asciidoc
fileTypes: [adoc, ad, asciidoc]
uuid: 961C6043-B725-4E2D-83E8-114BF3A7389D

patterns:
- include: '#lists'
- include: '#blocks'
- include: '#titles'
- include: '#lines'
- include: '#inline'
- include: '#characters'

repository:

#-----------------------------------------------------------------------------#
#                                 B L O C K S                                 #
#-----------------------------------------------------------------------------#

  blocks:
    patterns:
    - include: '#literal_block_announced'
    - include: '#literal_block_delimited'
    - include: '#comment_block'
    - include: '#listing_block'
    - include: '#sidebar_block'
    - include: '#passthrough_block'
    - include: '#quote_block'
    - include: '#example_block'
    - include: '#open_block'

  comment_block:
    comment: Comment block; note the big surprise that macros are enabled here.
    name: comment.block.asciidoc
    contentName: meta.block.comment.content.asciidoc
    begin: ^(/{4,})\s*$\n?
    beginCaptures:
      '0': {name: punctuation.definition.comment.begin.asciidoc}
    end: ^(/{4,})\s*$\n?
    endCaptures:
      '0': {name: punctuation.definition.comment.end.asciidoc}
    patterns:
    - include: '#macro'

  example_block:
    comment: >
      Might need to add more includes, but these are the ones that arise in
      practice for me; note restriction to 4 or 5 to distinguish from level 0
      setext.
    name: string.unquoted.block.example.asciidoc
    contentName: meta.block.example.content.asciidoc
    begin: ^(={4,5})\s*$\n?
    beginCaptures:
      '0': {name: constant.delimiter.example.begin.asciidoc}
    end: ^(={4,5})\s*$\n?
    endCaptures:
      '0': {name: constant.delimiter.example.end.asciidoc}
    patterns:
    - include: '#lists'
    - include: '#listing_block'
    - include: '#lines'
    - include: '#inline'
    - include: '#characters'

  listing_block:
    comment: >
      Declare content as source in order to get any extra yummy source
      goodness.
    name: meta.embedded.block.listing.asciidoc
    contentName: source.block.listing.content.asciidoc
    begin: ^(\-{4,5})\s*$\n?
    beginCaptures:
      '0': {name: constant.delimiter.listing.begin.asciidoc}
    end: ^(\-{4,5})\s*$\n?
    endCaptures:
      '0': {name: constant.delimiter.listing.end.asciidoc}
    patterns:
    - include: '#callout'

  literal_block_announced:
    comment: Section template announced as literal, starts literal block.
    name: string.literal.block.announced.asciidoc
    contentName: meta.block.literal.content.asciidoc
    begin: ^((\[)"?literal\"?,?.*(\]))\s*$\n?
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.attributelistline.begin.asciidoc}
      '3': {name: punctuation.definition.attributelistline.end.asciidoc}
    end: (?=^\s*$)
    patterns:
    - include: '#callout'

  literal_block_delimited:
    comment: Alternate way to get literal block, delimit with 4 or more periods.
    name: string.literal.block.delimited.asciidoc
    contentName: meta.block.literal.content.asciidoc
    begin: ^(\.{4,})\s*$\n?
    beginCaptures:
      '0': {name: constant.delimiter.block.literal.begin.asciidoc}
    end: ^(\.{4,})\s*$\n?
    endCaptures:
      '0': {name: constant.delimiter.block.literal.end.asciidoc}
    patterns:
    - include: '#callout'

  open_block:
    comment: Might need to check on these includes.
    name: meta.block.open.asciidoc
    contentName: meta.block.open.content.asciidoc
    begin: ^(\-\-)\s*$\n?
    beginCaptures:
      '0': {name: constant.delimiter.block.open.begin.asciidoc}
    end: ^(\-\-)\s*$\n?
    endCaptures:
      '0': {name: constant.delimiter.block.open.end.asciidoc}
    patterns:
    - include: '#lists'
    - include: '#comment_block'
    - include: '#listing_block'
    - include: '#passthrough_block'
    - include: '#lines'
    - include: '#inline'
    - include: '#characters'

  passthrough_block:
    comment: Must be four or five to distinguish from level 4 setext.
    name: meta.embedded.block.passthrough.asciidoc
    contentName: text.xml.block.passthrough.content.asciidoc
    begin: ^(\+{4,5})\s*$\n?
    beginCaptures:
      '0': {name: constant.delimiter.block.passthrough.begin.asciidoc}
    end: ^(\+{4,5})\s*$\n?
    endCaptures:
      '0': {name: constant.delimiter.block.passthrough.end.asciidoc}
    patterns:
    - include: text.xml

  quote_block:
    comment: >
      Might need to add more includes, but these are the ones that arise for me
      in practice.
    name: markup.quote.block.asciidoc
    contentName: meta.block.quote.content.asciidoc
    begin: ^(_{4,})\s*$\n?
    beginCaptures:
      '0': {name: constant.delimiter.block.quote.begin.asciidoc}
    end: ^(_{4,})\s*$\n?
    endCaptures:
      '0': {name: constant.delimiter.block.quote.end.asciidoc}
    patterns:
    - include: '#lines'
    - include: '#inline'
    - include: '#characters'

  sidebar_block:
    comment: >
      Might need to add more includes, but these are the ones that arise for me
      in practice.
    name: string.quoted.block.sidebar.asciidoc
    contentName: meta.block.sidebar.content.asciidoc
    begin: ^(\*{4,})\s*$\n?
    beginCaptures:
      '0': {name: constant.delimiter.block.sidebar.begin.asciidoc}
    end: ^(\*{4,})\s*$\n?
    endCaptures:
      '0': {name: constant.delimiter.block.sidebar.end.asciidoc}
    patterns:
    - include: '#lists'
    - include: '#comment_block'
    - include: '#listing_block'
    - include: '#lines'
    - include: '#inline'
    - include: '#characters'

  callout:
    comment: >
      Has to be alone in repository (not in a group), as it operates in only
      a couple of highly specific places.
    name: constant.other.callout.asciidoc
    match: (?<!\\)(<)\d+(>)
    captures:
      '1': {name: punctuation.definition.callout.begin.asciidoc}
      '2': {name: punctuation.definition.callout.end.asciidoc}


#-----------------------------------------------------------------------------#
#                             C H A R A C T E R S                             #
#-----------------------------------------------------------------------------#

  characters:
    patterns:
    - include: '#entity'
    - include: '#xmlentity'
    - include: '#escape'
    - include: '#replacement'
    - include: '#passmacro'
    - include: '#macro'
    - include: '#xref'
    - include: '#biblio_anchor'
    - include: '#index3'
    - include: '#index2'

  biblio_anchor:
    name: storage.type.reference.biblioanchor.asciidoc
    match: (?<!\[)(\[\[\[).*?(\]\]\])(?!\])
    captures:
      '1': {name: punctuation.definition.biblioanchor.begin.asciidoc}
      '2': {name: punctuation.definition.biblioanchor.end.asciidoc}

  entity:
    comment: '&#x278a; &#182;'
    name: constant.character.entity.asciidoc
    match: (?<!\\)&#(x[0-9a-fA-f]{4}|[0-9]{3});

  escape:
    comment: >
      I do not really know if this is a good list, adopted wholesale from
      original bundle.
    name: constant.character.escape.asciidoc
    match: \\(?=[-`*_#+.!(){}\[\]\\>:])

  index2:
    name: variable.other.indexterm.double.asciidoc
    match: (?<!\()(\({2})([^\(\s].*?)(\){2})(?!\))
    captures:
      '1': {name: constant.character.indexterm.double.begin.asciidoc}
      '3': {name: constant.character.indexterm.double.end.asciidoc}

  index3:
    name: variable.other.indexterm.triple.asciidoc
    match: (?<!\()(\({3})([^\(].*?)(\){3})(?!\))
    captures:
      '1': {name: constant.character.indexterm.triple.begin.asciidoc}
      '3': {name: constant.character.indexterm.triple.end.asciidoc}

  macro:
    comment: >
      There are other macro notations, but I match only those that end in
      square brackets.
    name: meta.macro.asciidoc
    match: |-
      (?x)
      (?:
        ((?:https?|mailto|ftp|file)  # specify separately so we can mark them as links that TextMate opens
        ?:{1}  # inline only
        \S*)   # (others such as image are partial URLs and/or TextMate cannot handle them)
      |
        (([a-zA-Z0-9][a-zA-Z0-9_]*)
        (:{1,2})
        (\S*))
      )
      (?:(\[)([^\]]*)(\]))
    captures:
      '1': {name: markup.underline.link.macro.asciidoc}
      '3': {name: keyword.control.name.macro.asciidoc}
      '4': {name: constant.character.separator.macro.asciidoc}
      '5': {name: markup.underline.target.macro.asciidoc}
      '6': {name: constant.character.attributes.macro.begin.asciidoc}
      '7': {name: variable.parameter.attributes.macro.asciidoc}
      '8': {name: constant.character.attributes.macro.end.asciidoc}

  passmacro:
    name: meta.macro.pass.asciidoc
    contentName: variable.parameter.attributes.macro.pass.asciidoc
    begin: |-
      (?x)
      (pass)
      (:{1,2})
      (\S*)
      (\[)(?=[^\]]*\])
    captures:
      '1': {name: keyword.control.name.macro.pass.asciidoc}
      '2': {name: constant.character.separator.macro.asciidoc}
      '3': {name: markup.underline.target.macro.asciidoc}
      '4': {name: constant.character.attributes.macro.begin.asciidoc}
    end: '\]'
    endCaptures:
      '0': {name: constant.character.attributes.macro.end.asciidoc}
    patterns:
    - include: text.xml

  replacement:
    comment: Replace me, my sweet replaceable you...
    name: constant.character.replacement.asciidoc
    match: |-
      (?x)
      (?<!\\)  # unless I am preceded by an escape, that is...
      (
        \(C\)
        |
        \(TM\)
        |
        \(R\)
        |
        ((?<!\-)\-\-(?!\-))  # exactly two, and even this may not rule out all that I want to
        |
        ((?<!\.)\.\.\.(?!\.))  # exactly three
        |
        \->;
        |
        <\-
        |
        =>;
        |
        <=
      )

  xmlentity:
    comment: amp, lt, gt
    name: constant.character.entity.xml.asciidoc
    match: (?<!\\)&(amp|lt|gt);

  xref:
    name: meta.xref.asciidoc
    match: (?<!<)(<<)([^,]*?)((,\s*)(.*?))?(>>)(?!<)
    captures:
      '1': {name: constant.character.xref.begin.asciidoc}
      '2': {name: markup.underline.term.xref.asciidoc}
      '5': {name: variable.parameter.xref.asciidoc}
      '6': {name: constant.character.xref.end.asciidoc}


#-----------------------------------------------------------------------------#
#                                I N L I N E S                                #
#-----------------------------------------------------------------------------#

  inline:
    patterns:
    - include: '#passthru'
    - include: '#double_bold'
    - include: '#double_italic'
    - include: '#double_literal'
    - include: '#double_unquoted'
    - include: '#single_bold'
    - include: '#single_italic'
    - include: '#single_literal'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#subscript'

  double_bold:
    name: markup.bold.double.asciidoc
    contentName: meta.boldinner.double.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?  # might start with an attribute list
      (?<!\\)         # must not be preceded by escape
      (\*\*)
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.bold.double.begin.asciidoc}
    end: '\*\*'
    endCaptures:
      '0': {name: punctuation.definition.bold.double.end.asciidoc}
    patterns:
    - include: '#double_italic'
    - include: '#double_literal'
    - include: '#double_unquoted'
    - include: '#single_italic'
    - include: '#single_literal'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  double_italic:
    name: markup.italic.double.asciidoc
    contentName: meta.italicinner.double.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?  # might start with attribute list
      (?<!\\)         # must not be preceded by escape
      (__)
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.italic.double.begin.asciidoc}
    end: '__'
    endCaptures:
      '0': {name: punctuation.definition.italic.double.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_literal'
    - include: '#double_unquoted'
    - include: '#single_bold'
    - include: '#single_literal'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  double_literal:
    name: string.other.literal.double.asciidoc
    contentName: meta.literalinner.double.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?  # might start with attribute list
      (?<!\\)         # must not be preceded by escape
      (``)
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.literal.double.begin.asciidoc}
    end: '``'
    endCaptures:
      '0': {name: punctuation.definition.literal.double.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_italic'
    - include: '#double_unquoted'
    - include: '#single_bold'
    - include: '#single_italic'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  double_unquoted:
    name: string.other.unquoted.double.asciidoc
    contentName: string.unquoted.unquotedinner.double.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?  # might start with an attribute list (indeed, that is its purpose)
      (?<!\\)         # must not be preceded by escape
      (\#\#)
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.string.unquoted.double.begin.asciidoc}
    end: '\#\#'
    endCaptures:
      '0': {name: punctuation.definition.string.unquoted.double.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_italic'
    - include: '#double_literal'
    - include: '#single_bold'
    - include: '#single_italic'
    - include: '#single_literal'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  passthru:
    comment: Must be dead first among the inlines, so as to take priority.
    name: meta.passthru.inline.asciidoc
    contentName: variable.parameter.passthruinner.asciidoc
    begin: (\+\+\+|\$\$)
    beginCaptures:
      '1': {name: constant.character.passthru.begin.asciidoc}
    end: '\1'
    endCaptures:
      '0': {name: constant.character.passthru.end.asciidoc}

  single_bold:
    name: markup.bold.single.asciidoc
    contentName: meta.boldinner.single.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?    # might start with an attributes list
      (?<=^|\W)(?<!\\)  # must be preceded by a nonword character, and not by an escape
      (\*)(?=\S)        # delimiter star that must be followed by a nonspace character
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.bold.single.begin.asciidoc}
    end: |-
      (?x)
      (?<=\S)(\*)       # delimiter star that must be preceded by a nonspace character
      (?!\w)            # ...and followed by a nonword character
    endCaptures:
      '1': {name: punctuation.definition.bold.single.end.asciidoc}
    patterns:
    - include: '#double_italic'
    - include: '#double_literal'
    - include: '#double_unquoted'
    - include: '#single_italic'
    - include: '#single_literal'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  single_italic:
    name: markup.italic.single.asciidoc
    contentName: meta.italicinner.single.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?    # might be preceded by an attributes list
      (?<=^|\W)(?<!\\)  # must be preceded by a nonword character, and not by an escape
      (_)(?=\S)         # delimiter underscore that must be followed by a nonspace character
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.italic.single.begin.asciidoc}
    end: |-
      (?x)
      (?<=\S)(_)        # delimiter underscore that must be preceded by a nonspace character
      (?!\w)            # ...and followed by a nonword character
    endCaptures:
      '1': {name: punctuation.definition.italic.single.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_literal'
    - include: '#double_unquoted'
    - include: '#single_bold'
    - include: '#single_literal'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  single_literal:
    name: string.other.literal.single.asciidoc
    contentName: meta.literalinner.single.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?    # might start with attributes list
      (?<=^|\W)(?<!\\)  # must be preceded by a nonword character, and not by escape
      (`)(?=\S)         # delimiter backtick that must be followed by a nonspace character
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.literal.single.begin.asciidoc}
    end: |-
      (?x)
      (?<=\S)(`)        # delimiter backtick that must be preceded by a nonspace character
      (?!\w)            # ...and followed by a nonword character
    endCaptures:
      '1': {name: punctuation.definition.literal.single.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_italic'
    - include: '#double_unquoted'
    - include: '#single_bold'
    - include: '#single_italic'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  single_unquoted:
    name: string.other.unquoted.single.asciidoc
    contentName: string.unquoted.unquotedinner.single.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?    # might start with attribute list (darned well better or why are we here)
      (?<=^|\W)(?<!\\)  # must be preceded by nonword character, and not by escape
      (\#)(?=\S)        # delimiter hash that must be followed by a nonspace character
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.string.unquoted.single.begin.asciidoc}
    end: |-
      (?x)
      (?<=\S)(\#)       # delimiter hash that must be preceded by a nonspace character
      (?!\w)            # ...and followed by a nonword character
    endCaptures:
      '1': {name: punctuation.definition.string.unquoted.single.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_italic'
    - include: '#double_literal'
    - include: '#single_bold'
    - include: '#single_italic'
    - include: '#single_literal'
    - include: '#superscript'
    - include: '#subscript'
    - include: '#characters'

  subscript:
    name: string.other.subscript.asciidoc
    contentName: meta.subscriptinner.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?  # might start with attribute list
      (?<!\\)         # must not be preceded by escape
      (~)
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.string.subscript.begin.asciidoc}
    end: '~'
    endCaptures:
      '0': {name: punctuation.definition.string.subscript.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_italic'
    - include: '#double_literal'
    - include: '#double_unquoted'
    - include: '#single_bold'
    - include: '#single_italic'
    - include: '#single_literal'
    - include: '#single_unquoted'
    - include: '#superscript'
    - include: '#characters'

  superscript:
    name: string.other.superscript.asciidoc
    contentName: meta.superscriptinner.asciidoc
    begin: |-
      (?x)
      (\[[^\]]*?\])?  # might start with attribute list
      (?<!\\)         # no preceding escape
      (\^)
    beginCaptures:
      '1': {name: support.variable.attributelist.asciidoc}
      '2': {name: punctuation.definition.string.superscript.begin.asciidoc}
    end: '^'
    endCaptures:
      '0': {name: punctuation.definition.string.superscript.end.asciidoc}
    patterns:
    - include: '#double_bold'
    - include: '#double_italic'
    - include: '#double_literal'
    - include: '#double_unquoted'
    - include: '#single_bold'
    - include: '#single_italic'
    - include: '#single_literal'
    - include: '#single_unquoted'
    - include: '#subscript'
    - include: '#characters'


#-----------------------------------------------------------------------------#
#                                  L I N E S                                  #
#-----------------------------------------------------------------------------#

  lines:
    patterns:
    - include: '#comment'
    - include: '#list_continuation'
    - include: '#linebreak'
    - include: '#pagebreak'
    - include: '#ruler'
    - include: '#block_heading'
    - include: '#block_id'
    - include: '#section_template'
    - include: '#attribute_list_line'
    - include: '#attribute_entry'

  comment:
    name: comment.line.double-slash.asciidoc
    match: ^(//)([^/\n].*|)$\n?
    captures:
      '1': {name: punctuation.definition.comment.line.asciidoc}
      '2': {name: meta.line.comment.content.asciidoc}

  attribute_entry:
    name: meta.attributeentry.asciidoc
    contentName: meta.attributeentry.value.asciidoc
    begin: |-
      (?x)
      ^(                            # attribute name
        (:)                         # delimiter
        (?:\w[^.]*?)(?:\.(?:.*?))?
        (:)                         # closer
      )
      (?:\s+|(?=$))
    beginCaptures:
      '1': {name: support.variable.attribute.asciidoc}
      '2': {name: punctuation.definition.attributeentry.attrname.begin.asciidoc}
      '3': {name: punctuation.definition.attributeentry.attrname.end.asciidoc}
    end: $\n?
    patterns:
    - include: '#characters'

  attribute_list_line:
    comment: >
      Attribute list as paragraph: single brackets. No need for special
      treatment of escape; follows literal block, section template as being a
      more general regex.
    name: support.variable.attributelist.asciidoc
    match: ^(\[)[^\[\]]*(\])\s*$\n?
    captures:
      '1': {name: punctuation.definition.attributelistline.begin.asciidoc}
      '2': {name: punctuation.definition.attributelistline.end.asciidoc}

  block_heading:
    comment: A line beginning with a period and no space.
    name: markup.heading.block.asciidoc
    match: ^(\.)\w.*$\n?
    captures:
      '1': {name: punctuation.definition.blockheading.asciidoc}

  block_id:
    comment: A line surrounded by double square brackets
    name: meta.tag.blockid.asciidoc
    match: ^(\[\[)([^\[].*)(\]\])\s*$\n?
    captures:
      '1': {name: punctuation.definition.blockid.begin.asciidoc}
      '2': {name: markup.underline.blockid.id.asciidoc}
      '3': {name: punctuation.definition.blockid.end.asciidoc}

  linebreak:
    name: constant.linebreak.asciidoc
    match: (?<=\s)\+$\n?

  list_continuation:
    name: constant.listcontinuation.asciidoc
    match: ^\+\s*$\n?

  pagebreak:
    name: meta.separator.pagebreak.asciidoc
    match: ^<{3,}$\n?

  ruler:
    name: meta.separator.ruler.asciidoc
    match: ^'{3,}$\n?

  section_template:
    comment: fixed list of known template names
    name: variable.parameter.sectiontemplate.asciidoc
    match: |-
      (?x)^
      (\[)  # in square brackets
      (template\s*=\s*)?(")?  # might start with template-equals and might have template name in quotes
      (
      sect\d|abstract|preface|colophon|dedication|glossary|bibliography|synopsis|appendix|index # fixed list of known templates
      )
      (".*(\])|(\]))  # either close the quote (and perhaps go on) and close the bracket, or close the bracket immediately
      \s*$\n?
    captures:
      '1': {name: punctuation.definition.sectiontemplate.begin.asciidoc}
      '4': {name: meta.tag.sectiontemplate.asciidoc}
      '6': {name: punctuation.definition.sectiontemplate.end.asciidoc}
      '7': {name: punctuation.definition.sectiontemplate.end.asciidoc}


#-----------------------------------------------------------------------------#
#                                  L I S T S                                  #
#-----------------------------------------------------------------------------#

  lists:
    comment: >
      My strategy for lists (and similar) is not to try to treat entire
      paragraphs as lists, but only call out the opening.
    patterns:
    - include: '#admonition_word'
    - include: '#bulleted_list'
    - include: '#numbered_list_dotted'
    - include: '#numbered_list_numeric'
    - include: '#numbered_list_roman'
    - include: '#labeled_list'
    - include: '#callout_list'

  admonition_word:
    comment: 'NOTE:, TIP:, IMPORTANT:, WARNING: or CAUTION:'
    name: support.constant.admonitionword.asciidoc
    match: ^(NOTE|TIP|IMPORTANT|WARNING|CAUTION):(?=\s+)

  bulleted_list:
    name: markup.list.bulleted.asciidoc
    match: ^(\s*(\-|\*{1,5}))\s+(?=\w)
    captures:
      '1': {name: string.unquoted.list.bullet.asciidoc}
      '2': {name: constant.numeric.list.bullet.asciidoc}

  callout_list:
    name: markup.list.numbered.callout.asciidoc
    match: ^(\s*((<)\d+?(>)))\s+(?=\w)
    captures:
      '1': {name: string.unquoted.list.callout.asciidoc}
      '2': {name: constant.numeric.callout.asciidoc}
      '3': {name: punctuation.definition.calloutlistnumber.begin.asciidoc}
      '4': {name: punctuation.definition.calloutlistnumber.end.asciidoc}

  labeled_list:
    comment: >
      Matches a label of the labeled list, not its content.
      This rule is not strictly correct, because Asciidoctor allows double
      colon followed by a space inside a label, i.e. it matches the *last*
      double colon, not the first. I don't know how to do that effectively.
    name: markup.list.labeled.asciidoc
    contentName: meta.list.label.asciidoc
    begin: ^\s*(?=.*:{2,4}(?:\s|$))
    end: (:{2,4})(?:\s|$\n?)
    endCaptures:
      '1': {name: constant.labeledlist.separator.asciidoc}
    patterns:
    - include: '#inline'
    - include: '#characters'

  numbered_list_dotted:
    comment: The space distinguishes it from a block title.
    name: markup.list.numbered.dotted.asciidoc
    match: ^(\s*(\.{1,5}))\s+(?=\w)
    captures:
      '1': {name: string.unquoted.list.dotted.asciidoc}
      '2': {name: constant.numeric.list.dot.asciidoc}

  numbered_list_numeric:
    name: markup.list.numbered.numeric.asciidoc
    match: ^(\s*([1-9a-zA-Z][0-9]*\.))\s+(?=\w)
    captures:
      '1': {name: string.unquoted.list.numeric.asciidoc}
      '2': {name: constant.numeric.list.number.asciidoc}

  numbered_list_roman:
    name: markup.list.numbered.roman.asciidoc
    match: ^(\s*([ivxIVX]+\)))\s+(?=\w)
    captures:
      '1': {name: string.unquoted.list.roman.asciidoc}
      '2': {name: constant.numeric.list.romannumeral.asciidoc}


#-----------------------------------------------------------------------------#
#                                 T I T L E S                                 #
#-----------------------------------------------------------------------------#

  titles:
    patterns:
    - include: '#title_level_5'
    - include: '#title_level_4'
    - include: '#title_level_3'
    - include: '#title_level_2'
    - include: '#title_level_1'
    - include: '#title_level_0'

  title_level_0:
    name: markup.heading.level.0.asciidoc
    match: ^(=) (\w.*)$\n?
    captures:
      '1': {name: punctuation.definition.heading.asciidoc}
      '2': {name: entity.name.section.asciidoc}

  title_level_1:
    name: markup.heading.level.1.asciidoc
    match: ^(==) (\w.*)$\n?
    captures:
      '1': {name: punctuation.definition.heading.asciidoc}
      '2': {name: entity.name.section.asciidoc}

  title_level_2:
    name: markup.heading.level.2.asciidoc
    match: ^(===) (\w.*)$\n?
    captures:
      '1': {name: punctuation.definition.heading.asciidoc}
      '2': {name: entity.name.section.asciidoc}

  title_level_3:
    name: markup.heading.level.3.asciidoc
    match: ^(====) (\w.*)$\n?
    captures:
      '1': {name: punctuation.definition.heading.asciidoc}
      '2': {name: entity.name.section.asciidoc}

  title_level_4:
    name: markup.heading.level.4.asciidoc
    match: ^(=====) (\w.*)$\n?
    captures:
      '1': {name: punctuation.definition.heading.asciidoc}
      '2': {name: entity.name.section.asciidoc}

  title_level_5:
    name: markup.heading.level.5.asciidoc
    match: ^(======) (\w.*)$\n?
    captures:
      '1': {name: punctuation.definition.heading.asciidoc}
      '2': {name: entity.name.section.asciidoc}
